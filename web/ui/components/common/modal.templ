package common

// Modal renders an accessible modal dialog with focus trap
// Includes keyboard support (Esc to close, Tab navigation)
// Properly manages focus and prevents background interaction
templ Modal(id string, title string, open bool) {
	<div
		x-data={ getModalAlpineData() }
		x-init={ "open = " + boolToString(open) }
		@keydown.escape.window="open = false"
		@keydown="trapFocus($event)"
		id={ id }
	>
		<!-- Backdrop -->
		<div
			x-show="open"
			x-cloak
			x-transition:enter="transition-opacity ease-out duration-300"
			x-transition:enter-start="opacity-0"
			x-transition:enter-end="opacity-100"
			x-transition:leave="transition-opacity ease-in duration-200"
			x-transition:leave-start="opacity-100"
			x-transition:leave-end="opacity-0"
			@click="open = false"
			class="fixed inset-0 bg-slate-900/50 backdrop-blur-sm z-50"
			aria-hidden="true"
		></div>

		<!-- Modal Panel -->
		<div
			x-show="open"
			x-cloak
			class="fixed inset-0 z-50 flex items-center justify-center p-4 sm:p-6 md:p-20"
			role="dialog"
			aria-modal="true"
			aria-labelledby={ id + "-title" }
		>
			<div
				x-ref="modalContent"
				x-show="open"
				x-transition:enter="transition ease-out duration-300"
				x-transition:enter-start="opacity-0 scale-95"
				x-transition:enter-end="opacity-100 scale-100"
				x-transition:leave="transition ease-in duration-200"
				x-transition:leave-start="opacity-100 scale-100"
				x-transition:leave-end="opacity-0 scale-95"
				@click.stop
				class="relative bg-white rounded-2xl shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-hidden"
			>
				<!-- Header -->
				<div class="flex items-center justify-between px-6 py-4 border-b border-slate-200">
					<h2
						id={ id + "-title" }
						class="text-xl font-semibold text-slate-900"
					>
						{ title }
					</h2>
					<button
						@click="open = false"
						type="button"
						class="p-2 text-slate-400 hover:text-slate-600 hover:bg-slate-100 rounded-lg focus:outline-none focus:ring-2 focus:ring-slate-500 transition-colors"
						aria-label="Close modal"
					>
						<span class="sr-only">Close</span>
						<svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
						</svg>
					</button>
				</div>

				<!-- Content -->
				<div class="px-6 py-4 overflow-y-auto max-h-[calc(90vh-140px)]">
					{ children... }
				</div>

				<!-- Footer (optional) -->
				<div class="flex items-center justify-end gap-3 px-6 py-4 border-t border-slate-200 bg-slate-50">
					<button
						@click="open = false"
						type="button"
						class="inline-flex items-center justify-center rounded-full px-7 py-3.5 font-semibold text-sm border border-slate-900/25 text-slate-900 bg-white hover:bg-slate-50 transition-all duration-150"
						aria-label="Cancel and close modal"
					>
						Cancel
					</button>
					<button
						type="button"
						class="inline-flex items-center justify-center rounded-full px-7 py-3.5 font-semibold text-sm bg-gradient-to-r from-slate-900 to-slate-700 text-white shadow-lg hover:-translate-y-0.5 hover:shadow-xl transition-all duration-150"
						aria-label="Confirm action"
					>
						Confirm
					</button>
				</div>
			</div>
		</div>
	</div>
}

func boolToString(b bool) string {
	if b {
		return "true"
	}
	return "false"
}

func getModalAlpineData() string {
	return `{
		open: false,
		focusableElements: [],
		firstFocusable: null,
		lastFocusable: null,
		previouslyFocused: null,
		init() {
			this.$watch('open', value => {
				if (value) {
					this.previouslyFocused = document.activeElement;
					this.$nextTick(() => {
						this.focusableElements = Array.from(
							this.$refs.modalContent.querySelectorAll(
								'a[href], button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex="-1"])'
							)
						);
						this.firstFocusable = this.focusableElements[0];
						this.lastFocusable = this.focusableElements[this.focusableElements.length - 1];
						if (this.firstFocusable) {
							this.firstFocusable.focus();
						}
					});
				} else {
					if (this.previouslyFocused) {
						this.previouslyFocused.focus();
					}
				}
			});
		},
		trapFocus(e) {
			if (e.key === 'Tab') {
				if (this.focusableElements.length === 0) {
					e.preventDefault();
					return;
				}
				if (e.shiftKey) {
					if (document.activeElement === this.firstFocusable) {
						e.preventDefault();
						this.lastFocusable.focus();
					}
				} else {
					if (document.activeElement === this.lastFocusable) {
						e.preventDefault();
						this.firstFocusable.focus();
					}
				}
			}
		}
	}`
}

package data

import (
	"fmt"
)

type BarChartConfig struct {
	ID          string
	Title       string
	Description string
	Labels      []string
	Datasets    []ChartDataset
	Height      string
	Stacked     bool
	Horizontal  bool
	ShowLegend  bool
	ShowExport  bool
}

type ChartDataset struct {
	Label           string
	Data            []float64
	BackgroundColor string
	BorderColor     string
}

// BarChart creates a Chart.js bar chart for cost comparisons
templ BarChart(config BarChartConfig) {
	@ChartWrapper(ChartConfig{
		ID:          config.ID,
		Title:       config.Title,
		Description: config.Description,
		Height:      config.Height,
		ShowExport:  config.ShowExport,
	}) {
		<canvas
			id={ config.ID }
			x-data={ fmt.Sprintf(`{
				chart: null,
				init() {
					const ctx = document.getElementById('%s').getContext('2d');
					this.chart = new Chart(ctx, {
						type: '%s',
						data: {
							labels: %s,
							datasets: %s
						},
						options: {
							responsive: true,
							maintainAspectRatio: false,
							indexAxis: '%s',
							plugins: {
								legend: {
									display: %t,
									position: 'top',
									labels: {
										font: {
											family: 'Inter, sans-serif',
											size: 12
										},
										padding: 16,
										usePointStyle: true
									}
								},
								tooltip: {
									backgroundColor: 'rgba(15, 23, 42, 0.95)',
									titleFont: {
										family: 'Inter, sans-serif',
										size: 13,
										weight: '600'
									},
									bodyFont: {
										family: 'Inter, sans-serif',
										size: 12
									},
									padding: 12,
									cornerRadius: 8,
									displayColors: true,
									callbacks: {
										label: function(context) {
											let label = context.dataset.label || '';
											if (label) {
												label += ': ';
											}
											if (context.parsed.y !== null) {
												label += new Intl.NumberFormat('en-US', {
													style: 'currency',
													currency: 'AED'
												}).format(context.parsed.y);
											}
											return label;
										}
									}
								}
							},
							scales: {
								x: {
									stacked: %t,
									grid: {
										display: false
									},
									ticks: {
										font: {
											family: 'Inter, sans-serif',
											size: 11
										}
									}
								},
								y: {
									stacked: %t,
									beginAtZero: true,
									grid: {
										color: 'rgba(148, 163, 184, 0.1)'
									},
									ticks: {
										font: {
											family: 'Inter, sans-serif',
											size: 11
										},
										callback: function(value) {
											return new Intl.NumberFormat('en-US', {
												style: 'currency',
												currency: 'AED',
												minimumFractionDigits: 0
											}).format(value);
										}
									}
								}
							},
							interaction: {
								intersect: false,
								mode: 'index'
							}
						}
					});

					// Store chart instance globally for export
					window.charts = window.charts || {};
					window.charts['%s'] = this.chart;
				},
				destroy() {
					if (this.chart) {
						this.chart.destroy();
					}
				}
			}`, config.ID, chartType(config.Horizontal), labelsJSON(config.Labels), datasetsJSON(config.Datasets), indexAxis(config.Horizontal), config.ShowLegend, config.Stacked, config.Stacked, config.ID) }
			x-init="init()"
			x-destroy="destroy()"
		></canvas>
	}
}

func chartType(horizontal bool) string {
	return "bar"
}

func indexAxis(horizontal bool) string {
	if horizontal {
		return "y"
	}
	return "x"
}

func labelsJSON(labels []string) string {
	// This would properly marshal to JSON
	return "[]"
}

func datasetsJSON(datasets []ChartDataset) string {
	// This would properly marshal to JSON with colors
	return "[]"
}
